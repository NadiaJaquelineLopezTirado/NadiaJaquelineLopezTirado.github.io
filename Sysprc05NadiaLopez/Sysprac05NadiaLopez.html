
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Pr&aacute;ctica 5: Series de Fourier en tiempo continuo</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-05-14"><meta name="DC.source" content="practica 5.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Pr&aacute;ctica 5: Series de Fourier en tiempo continuo</h1><!--introduction--><pre class="codeoutput error">Error using evalin
Undefined function 'practica' for input arguments of type 'char'.
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Portada</a></li><li><a href="#2">Objetivos</a></li><li><a href="#3">Introducci&oacute;n</a></li><li><a href="#4">Desarrollo</a></li><li><a href="#5">Ejemplo 6.1</a></li><li><a href="#7">Ejemplo 6.2</a></li><li><a href="#9">Ejemplo 6.4</a></li><li><a href="#11">Ejercicio 6.5</a></li><li><a href="#13">Ejemplo 6.7</a></li><li><a href="#15">Elaboracion de codigo</a></li><li><a href="#16">Elabore un c&oacute;digo que implemente el algoritmo de trapecio compuesto</a></li></ul></div><h2 id="1">Portada</h2><p>
<div align="right">
<IMG src="upiita-logo.png" width="100" height="95"/>
</div>
<div align="left">
<IMG src="ipn.png" width="100" height="95"/>
</div>
<div align="center">
<h2>INSTITUTO POLITECNICO NACIONAL</h2>
<h2> UNIDAD PROFESIONAL INTERDISCIPLINARIA EN INGENIERÍA Y TECNOLOGÍAS AVANZADAS </h2>
<h2> SEÑALES Y SISTEMAS </h2>
</div>
<div align="center">
<p> Profesor: Dr. Rafael Martinez Martinez </p>
<strong>INTEGRANTES DEL EQUIPO:</strong>
<ol>
<strong>LÓPEZ TIRADO NADIA JAQUELINE</strong><br/>
<strong>HERNÁNDEZ CASTILLO FRANCISCO</strong>
</ol>
<strong>Grupo 2TV1</strong><br/>
</div>
</p><h2 id="2">Objetivos</h2><p>Los objetivos son los siguientes:</p><div><ul><li>Realizar gr&aacute;ficas de series de Fourier exponenciales y trigonom&eacute;tricas en tiempo continuo</li><li>Manipulaci&oacute;n de instrucciones en MATLAB</li><li>Simular convoluciones y correlaciones de se&ntilde;ales continuasCalculo n&uacute;merico de los coeficientes de Fourier</li></ul></div><h2 id="3">Introducci&oacute;n</h2><p>Podemos computar DN num&eacute;ricamente usando la DFT (la transformada discreta de Fourier), que utiliza las muestras de una se&ntilde;al peri&oacute;dica x (t) durante un per&iacute;odo. El intervalo de muestreo es T segundos. Por lo tanto, hay <img src="practica 5_eq17991288398453338376.png" alt="$N_0 = T_0/T$"> n&uacute;mero de muestras en un per&iacute;odo <img src="practica 5_eq09699377331652163485.png" alt="$T_0$">. Para encontrar la relaci&oacute;n entre DN y las muestras de x (t),</p><p><img src="practica 5_eq17778624778531596451.png" alt="$$ D_n= \frac{1}{T_0}\int_{T_0} X(t) e^(-jn\varpi kT) dt $$"></p><p><img src="practica 5_eq11190214900401658562.png" alt="$$\lim_{T \rightarrow 0} \frac{1}{N_0 T} \sum _{k=0}^{N_0}-1  X(kT)e^(-jn\varpi kT) T$$"></p><p><img src="practica 5_eq13449574423443206276.png" alt="$$\lim_{T \rightarrow 0}\frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$"></p><p>donde x (kT) es la muestra KTH de x (t) y</p><p><img src="practica 5_eq07887746378795506936.png" alt="$$N_0 = \frac{T_0}{T}$$"></p><p><img src="practica 5_eq13221431130412380006.png" alt="$$\Omega_0 = \varpi_0 T = \frac{2\pi }{N_0}$$"></p><p>En la pr&aacute;ctica, es imposible hacer <img src="practica 5_eq05130068492524870277.png" alt="$T \rightarrow 0$"> . Podemos hacer T peque&ntilde;o, pero no cero, lo que provocar&aacute; que los datos aumenten sin l&iacute;mite. Por lo tanto, ignoraremos el l&iacute;mite en T con la comprensi&oacute;n impl&iacute;cita de que T es razonablemente peque&ntilde;o. T distinto de cero dar&aacute; lugar a alg&uacute;n error computacional, que es inevitable en cualquier evaluaci&oacute;n num&eacute;rica de una integral.El error resultante de T distinto de cero se denomina error de aliasing. Por lo tanto, podemos expresar como:</p><p><img src="practica 5_eq11268195034532418783.png" alt="$$D_n= \frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$"></p><p>Ahora, <img src="practica 5_eq15516621093487325427.png" alt="$\Omega_0 N_0 = 2 ?$">. Por lo tanto, ej <img src="practica 5_eq14182432737433056036.png" alt="$\Omega_0$"> (k + N 0) = ej ? 0 k sigue que <img src="practica 5_eq04987746277794382069.png" alt="$$D_n+N_0=D_n$">$ La propiedad de periodicidad DN + N0 = DN significa que m&aacute;s all&aacute; de n = N0/2, los coeficientes representan los valores para n negativo.Por ejemplo, cuando <img src="practica 5_eq06141195695409630420.png" alt="$N_0 = 32, D17 = D-15, D18 = D-14,..., D31 = D-1$">. El ciclo se repite de nuevo a partir de n = 32. Para este proposito necesitamos muestras de x (t) durante un per&iacute;odo a partir de t = 0. En este algoritmo, tambi&eacute;n es preferible que <img src="practica 5_eq14438439004078460794.png" alt="$N_0$"> sea una potencia de 2, que es <img src="practica 5_eq09467365718498806247.png" alt="$N_0 = 2^m$">, donde m es un entero.</p><h2 id="4">Desarrollo</h2><h2 id="5">Ejemplo 6.1</h2><p>Con serie y espectro trigonometrico, no es necesario entregar el c&oacute;digo, solo la aplicaci&oacute;n al problema especifico, debe de indicar la funci&oacute;n y los valores de sus coeficientes (sin incluir el procedimiento)</p><p><img vspace="5" hspace="5" src="61.PNG" alt=""> </p><h2 id="7">Ejemplo 6.2</h2><p>Con serie y espectro exponencial y A=3, no es necesario entregar el c&oacute;digo, solo la aplicaci&oacute;n al problema especifico, debe de indicar la funci&oacute;n y los valores de sus coeficientes (sin incluir el procedimiento)</p><p><img vspace="5" hspace="5" src="62.PNG" alt=""> </p><h2 id="9">Ejemplo 6.4</h2><p>Con serie y espectro exponencial, no es necesario entregar el c&oacute;digo, solo la aplicaci&oacute;n al problema especifico, debe de indicar la funci&oacute;n y los valores de sus coeficientes (sin incluir el procedimiento)</p><p><img vspace="5" hspace="5" src="64.PNG" alt=""> </p><h2 id="11">Ejercicio 6.5</h2><p>Con serie y espectro exponencial, no es necesario entregar el c&oacute;digo, solo la aplicaci&oacute;n al problema especifico, debe de indicar la funci&oacute;n y los valores de sus coeficientes (sin incluir el procedimiento)</p><p><img vspace="5" hspace="5" src="65.PNG" alt=""> </p><h2 id="13">Ejemplo 6.7</h2><p>Con serie y espectro exponencial y <img src="practica 5_eq04356084194358646376.png" alt="$T_0=3$"> sin incluir la gr&aacute;fica de f, error ni energ&iacute;a del error, no es necesario entregar el c&oacute;digo, solo la aplicaci&oacute;n al problema especifico, debe de indicar la funci&oacute;n y los valores de sus coeficientes (sin incluir el procedimiento)</p><p><img vspace="5" hspace="5" src="67.PNG" alt=""> </p><h2 id="15">Elaboracion de codigo</h2><p>Elabore un c&oacute;digo similar al COMPUTER EXAMPLE C6.2 que se encuentra al final de la secci&oacute;n 6.2 de Lathi para el Ejempo 6.2 con los datos indicados anteriormente (no utilice inline)</p><h2 id="16">Elabore un c&oacute;digo que implemente el algoritmo de trapecio compuesto</h2><p>Elabore un c&oacute;digo que implemente el algoritmo de trapecio compuesto para <img src="practica 5_eq08501079337458606022.png" alt="$n=15$">, Utilice este c&oacute;digo para aproximar <img src="practica 5_eq12324390629844581234.png" alt="$D_0,...,D_4$"> del ejemplo de la pr&aacute;ctica. Ahora implemente el c&oacute;digo COMPUTER EXAMPLE C6.4 que se encuentra al final de la secci&oacute;n 6.6 de Lathi, y calcule nuevamente el los coeficientes <img src="practica 5_eq12324390629844581234.png" alt="$D_0,...,D_4$"> del ejemplo propuesto. Muestre una tabla que contenga los coeficientes mencionados calculados con los dos algoritmos y de forma exacta, &iquest;Qu&eacute; algortmo aproxima mejor a los coeficientes?, para esto compare los coefientes con el valor absoluto de la resta.</p><pre class="codeinput">T_0 = pi; N_0 = 256; T = T_0/N_0; t = (0:T:T*(N_0-1))'; M = 10;
x = exp(-t/2); x(1) = (exp(-pi/2) + 1)/2;


figure(1)
D_n = fft (x)/N_0; n = [-N_0/2:N_0/2-1]';

<span class="keyword">for</span> a = 1:1:5
mag_dft(a)=abs(fftshift(D_n(a)));
<span class="keyword">end</span>
<span class="keyword">for</span> a = 1:1:5
ang_dft(a)=angle(fftshift(D_n(a)));
<span class="keyword">end</span>
mag_dft
ang_dft
clf; subplot (2, 2, 1); stem(n, abs(fftshift (D_n)),<span class="string">'k'</span>);
axis ([-M M -.1 .6]); xlabel(<span class="string">'n'</span>); ylabel(<span class="string">'|D_n|'</span>);
subplot (2, 2, 2); stem(n, angle(fftshift(D_n)),<span class="string">'k'</span>);
axis([-M M -pi pi]); xlabel (<span class="string">'n'</span>); ylabel(<span class="string">'\angle D n [rad]'</span>);


T_0 = pi; N_0 = 256; T = T_0/N_0; W_0=2*pi/T_0; t = (0:T:T*(N_0-1))'; M = 10;

x_0 =@(t) exp(-t/2);
x_1 =@(t) exp(-t/2)*exp(-1j*W_0*t);
x_2 =@(t) exp(-t/2)*exp(-2j*W_0*t);
x_3 =@(t) exp(-t/2)*exp(-3j*W_0*t);
x_4 =@(t) exp(-t/2)*exp(-4j*W_0*t);
</pre><pre>(n positiva) por trapecio compuesto</pre><pre class="codeinput">figure(2)
n=[0:1:4];
D_n=[trap_com(x_0,0,pi,pi/2)/T_0,trap_com(x_1,0,pi,pi/2)/T_0,trap_com(x_2,0,pi,pi/2)/T_0,trap_com(x_3,0,pi,pi/2)/T_0,trap_com(x_4,0,pi,pi/2)/T_0];
mag_trap=abs(D_n)
ang_trap=angle(D_n)

clf; subplot (2, 2, 1); stem(n, abs( (D_n)),<span class="string">'k'</span>);
axis ([-M M -.1 .6]); xlabel(<span class="string">'n'</span>); ylabel(<span class="string">'|D_n|'</span>);
subplot (2, 2, 2); stem(n, angle((D_n)),<span class="string">'k'</span>);
axis([-M M -pi pi]); xlabel (<span class="string">'n'</span>); ylabel(<span class="string">'\angle D n [rad]'</span>);
hold <span class="string">on</span>
</pre><p>De acuerdo a Lathi, en el ejemplo 6.5, que se desarroll&oacute; en el R10, la serie de Fourier exponencial compleja tiene Dn: <img src="practica 5_eq11462128157880710935.png" alt="$\left.\frac{-1}{\pi (1/2+j2n)}e^{-(1/2+j2n)t}\right |_{t=0}^{\pi}$"> Para llegar al resultado m&aacute;s preciso, no se utiliz&oacute; el resultado final de Lathi que indica <img src="practica 5_eq11815252062284937394.png" alt="$\frac{0.504}{1+j4n}$">. Sino que desarrollando, se encontr&oacute;: <img src="practica 5_eq08029797175683308747.png" alt="$\frac{-1}{\pi (1/2+j2n)}(e^{-\frac{\pi}{2}}-1)$"></p><pre class="codeinput"><span class="keyword">for</span> n=2:1:5
   mag_ex(n)=abs((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1))));
<span class="keyword">end</span>
mag_ex(1)=abs((-exp(-pi/2)+1)/(pi*(0.5)));

<span class="keyword">for</span> n=2:1:5
   ang_ex(n)=angle((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1))));
<span class="keyword">end</span>
ang_ex(1)=angle((-exp(-pi/2)+1)/(pi*(0.5)));

T = table(mag_dft',ang_dft',mag_trap',ang_trap',mag_ex',ang_ex'); T(1:5,:);
T.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
T.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'Abs_DFT'</span>;
T.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'Ang_DFT'</span>;
T.Properties.VariableNames{<span class="string">'Var3'</span>} = <span class="string">'Abs_Trap_Com'</span>;
T.Properties.VariableNames{<span class="string">'Var4'</span>} = <span class="string">'Ang_Trap_Com'</span>;
T.Properties.VariableNames{<span class="string">'Var5'</span>} = <span class="string">'Abs_Exacto'</span>;
T.Properties.VariableNames{<span class="string">'Var6'</span>} = <span class="string">'Ang_Exacto'</span>
</pre><p>En su forma rectangular</p><pre class="codeinput">DFT=mag_dft.*exp(1j.*ang_dft);
TRAP=mag_trap.*exp(1j*ang_trap);
EXAC=mag_ex.*exp(1j*ang_ex);

D= table(DFT',TRAP',EXAC');
D.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
D.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'Dn_por_DFT'</span>;
D.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'Dn_por_Trap_comp'</span>;
D.Properties.VariableNames{<span class="string">'Var3'</span>} = <span class="string">'Dn_exacto'</span>
</pre><p>Comparaci&oacute;n</p><pre class="codeinput">DFT_EXAC=abs(EXAC-DFT);
TRAP_EXAC=abs(EXAC-TRAP);

CMP= table(DFT_EXAC',TRAP_EXAC');
CMP.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
CMP.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'ERROR_DFT'</span>;
CMP.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'ERROR_TRAP'</span>
</pre><p>Por lo tanto se puede ver que el algoritmo DFT es m&aacute;s preciso que el del trapecio compuesto, puesto que hubo menor error que el valor exacto.</p><p><img vspace="5" hspace="5" src="71.PNG" alt=""> </p><p><img vspace="5" hspace="5" src="72.PNG" alt=""> </p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Práctica 5: Series de Fourier en tiempo continuo 
%
%% Portada
% <html>
% <div align="right">
% <IMG src="upiita-logo.png" width="100" height="95"/>
% </div>
% <div align="left">
% <IMG src="ipn.png" width="100" height="95"/>
% </div>
% <div align="center">
% <h2>INSTITUTO POLITECNICO NACIONAL</h2>
% <h2> UNIDAD PROFESIONAL INTERDISCIPLINARIA EN INGENIERÍA Y TECNOLOGÍAS AVANZADAS </h2>
% <h2> SEÑALES Y SISTEMAS </h2>
% </div>
% <div align="center">
% <p> Profesor: Dr. Rafael Martinez Martinez </p>
% <strong>INTEGRANTES DEL EQUIPO:</strong>
% <ol>
% <strong>LÓPEZ TIRADO NADIA JAQUELINE</strong><br/> 
% <strong>HERNÁNDEZ CASTILLO FRANCISCO</strong>
% </ol>
% <strong>Grupo 2TV1</strong><br/>
% </div>
% </html>


%% Objetivos
% Los objetivos son los siguientes:
%
% * Realizar gráficas de series de Fourier exponenciales y trigonométricas en tiempo continuo 
% * Manipulación de instrucciones en MATLAB
% * Simular convoluciones y correlaciones de señales continuasCalculo númerico de los coeficientes de Fourier

%% Introducción
% Podemos computar DN numéricamente usando la DFT (la transformada discreta de Fourier), que utiliza las muestras
% de una señal periódica x (t) durante un período.
% El intervalo de muestreo es T segundos. Por lo tanto, hay $N_0 = T_0/T$ número de muestras en un 
% período $T_0$. Para encontrar la relación entre DN y las muestras de x (t),
% 
% $$ D_n= \frac{1}{T_0}\int_{T_0} X(t) e^(-jn\varpi kT) dt $$ 
% 
% $$\lim_{T \rightarrow 0} \frac{1}{N_0 T} \sum _{k=0}^{N_0}-1  X(kT)e^(-jn\varpi kT) T$$
% 
% $$\lim_{T \rightarrow 0}\frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$
% 
% donde x (kT) es la muestra KTH de x (t) y
% 
% $$N_0 = \frac{T_0}{T}$$ 
% 
% $$\Omega_0 = \varpi_0 T = \frac{2\pi }{N_0}$$
% 
% En la práctica, es imposible hacer $T \rightarrow 0$ . Podemos hacer T pequeño, pero no cero, lo que 
% provocará que los datos aumenten sin límite.
% Por lo tanto, ignoraremos el límite en T con la comprensión implícita de que T es razonablemente
% pequeño. T distinto de cero dará lugar a algún error computacional, que es inevitable en cualquier 
% evaluación numérica de una integral.El error resultante de T distinto de cero se denomina error de 
% aliasing. Por lo tanto, podemos expresar como:
% 
% $$D_n= \frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$
%
% Ahora, $\Omega_0 N_0 = 2 ?$. Por lo tanto, ej $\Omega_0$ (k + N 0) = ej ? 0 k sigue que
% $$D_n+N_0=D_n$$
% La propiedad de periodicidad DN + N0 = DN significa que más allá de n = N0/2, los coeficientes
% representan los valores para n negativo.Por ejemplo, cuando $N_0 = 32, D17 = D-15, D18 = D-14,..., D31 
% = D-1$. El ciclo se repite de nuevo a partir de n = 32.
% Para este proposito necesitamos muestras de x (t) durante un período a partir de t = 0. En este 
% algoritmo, también es preferible que $N_0$ sea una potencia de 2, que es $N_0 = 2^m$, donde m es
% un entero.


%% Desarrollo
%% Ejemplo 6.1
% Con serie y espectro trigonometrico, no es necesario entregar el código, solo la aplicación al problema especifico, debe de indicar la función y los valores de sus coeficientes (sin incluir el procedimiento)
%%
% 
% 
% <<61.PNG>>
% 
% 

%% Ejemplo 6.2
% Con serie y espectro exponencial y A=3, no es necesario entregar el código, solo la aplicación al problema especifico, debe de indicar la función y los valores de sus coeficientes (sin incluir el procedimiento)
%%
% 
% <<62.PNG>>
% 

%% Ejemplo 6.4
% Con serie y espectro exponencial, no es necesario entregar el código, solo la aplicación al problema especifico, debe de indicar la función y los valores de sus coeficientes (sin incluir el procedimiento)
%%
% 
% <<64.PNG>>
% 

%% Ejercicio 6.5
% Con serie y espectro exponencial, no es necesario entregar el código, solo la aplicación al problema especifico, debe de indicar la función y los valores de sus coeficientes (sin incluir el procedimiento)
%%
% 
% <<65.PNG>>
% 

%% Ejemplo 6.7
% Con serie y espectro exponencial y $T_0=3$ sin incluir la gráfica de f, error ni energía del error, no es necesario entregar el código, solo la aplicación al problema especifico, debe de indicar la función y los valores de sus coeficientes (sin incluir el procedimiento)
%%
% 
% <<67.PNG>>
% 

%% Elaboracion de codigo
% Elabore un código similar al COMPUTER EXAMPLE C6.2 que se encuentra al final de la sección 6.2 de Lathi para el Ejempo 6.2 con los datos indicados anteriormente (no utilice inline)
%% Elabore un código que implemente el algoritmo de trapecio compuesto
% Elabore un código que implemente el algoritmo de trapecio compuesto para $n=15$, Utilice este código para aproximar $D_0,...,D_4$ del ejemplo de la práctica. Ahora implemente el código COMPUTER EXAMPLE C6.4 que se encuentra al final de la sección 6.6 de Lathi, y calcule nuevamente el los coeficientes $D_0,...,D_4$ del ejemplo propuesto. Muestre una tabla que contenga los coeficientes mencionados calculados con los dos algoritmos y de forma exacta, ¿Qué algortmo aproxima mejor a los coeficientes?, para esto compare los coefientes con el valor absoluto de la resta. 
% 
T_0 = pi; N_0 = 256; T = T_0/N_0; t = (0:T:T*(N_0-1))'; M = 10;
x = exp(-t/2); x(1) = (exp(-pi/2) + 1)/2;


figure(1)
D_n = fft (x)/N_0; n = [-N_0/2:N_0/2-1]';

for a = 1:1:5
mag_dft(a)=abs(fftshift(D_n(a)));
end
for a = 1:1:5
ang_dft(a)=angle(fftshift(D_n(a)));
end
mag_dft
ang_dft
clf; subplot (2, 2, 1); stem(n, abs(fftshift (D_n)),'k');
axis ([-M M -.1 .6]); xlabel('n'); ylabel('|D_n|');
subplot (2, 2, 2); stem(n, angle(fftshift(D_n)),'k');
axis([-M M -pi pi]); xlabel ('n'); ylabel('\angle D n [rad]');


T_0 = pi; N_0 = 256; T = T_0/N_0; W_0=2*pi/T_0; t = (0:T:T*(N_0-1))'; M = 10;

x_0 =@(t) exp(-t/2);
x_1 =@(t) exp(-t/2)*exp(-1j*W_0*t);
x_2 =@(t) exp(-t/2)*exp(-2j*W_0*t);
x_3 =@(t) exp(-t/2)*exp(-3j*W_0*t);
x_4 =@(t) exp(-t/2)*exp(-4j*W_0*t);


%%
% 
%  (n positiva) por trapecio compuesto
%  
% 


figure(2)
n=[0:1:4];
D_n=[trap_com(x_0,0,pi,pi/2)/T_0,trap_com(x_1,0,pi,pi/2)/T_0,trap_com(x_2,0,pi,pi/2)/T_0,trap_com(x_3,0,pi,pi/2)/T_0,trap_com(x_4,0,pi,pi/2)/T_0];
mag_trap=abs(D_n)
ang_trap=angle(D_n)

clf; subplot (2, 2, 1); stem(n, abs( (D_n)),'k');
axis ([-M M -.1 .6]); xlabel('n'); ylabel('|D_n|');
subplot (2, 2, 2); stem(n, angle((D_n)),'k');
axis([-M M -pi pi]); xlabel ('n'); ylabel('\angle D n [rad]');
hold on
%%
% 
% De acuerdo a Lathi, en el ejemplo 6.5, que se desarrolló en el R10, la
% serie de Fourier exponencial compleja tiene Dn:
% $\left.\frac{-1}{\pi (1/2+j2n)}e^{-(1/2+j2n)t}\right |_{t=0}^{\pi}$
% Para llegar al resultado más preciso, no se utilizó el resultado final de
% Lathi que indica $\frac{0.504}{1+j4n}$. Sino que desarrollando, se
% encontró: $\frac{-1}{\pi (1/2+j2n)}(e^{-\frac{\pi}{2}}-1)$
% 

for n=2:1:5
   mag_ex(n)=abs((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1)))); 
end
mag_ex(1)=abs((-exp(-pi/2)+1)/(pi*(0.5)));

for n=2:1:5
   ang_ex(n)=angle((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1)))); 
end
ang_ex(1)=angle((-exp(-pi/2)+1)/(pi*(0.5)));

T = table(mag_dft',ang_dft',mag_trap',ang_trap',mag_ex',ang_ex'); T(1:5,:);
T.Properties.RowNames = {'D0','D1','D2','D3','D4'};
T.Properties.VariableNames{'Var1'} = 'Abs_DFT';
T.Properties.VariableNames{'Var2'} = 'Ang_DFT';
T.Properties.VariableNames{'Var3'} = 'Abs_Trap_Com';
T.Properties.VariableNames{'Var4'} = 'Ang_Trap_Com';
T.Properties.VariableNames{'Var5'} = 'Abs_Exacto';
T.Properties.VariableNames{'Var6'} = 'Ang_Exacto'

%%
% 
% En su forma rectangular
% 


DFT=mag_dft.*exp(1j.*ang_dft);
TRAP=mag_trap.*exp(1j*ang_trap);
EXAC=mag_ex.*exp(1j*ang_ex);

D= table(DFT',TRAP',EXAC');
D.Properties.RowNames = {'D0','D1','D2','D3','D4'};
D.Properties.VariableNames{'Var1'} = 'Dn_por_DFT';
D.Properties.VariableNames{'Var2'} = 'Dn_por_Trap_comp';
D.Properties.VariableNames{'Var3'} = 'Dn_exacto'
%%
% 
% Comparación
% 

DFT_EXAC=abs(EXAC-DFT);
TRAP_EXAC=abs(EXAC-TRAP);

CMP= table(DFT_EXAC',TRAP_EXAC');
CMP.Properties.RowNames = {'D0','D1','D2','D3','D4'};
CMP.Properties.VariableNames{'Var1'} = 'ERROR_DFT';
CMP.Properties.VariableNames{'Var2'} = 'ERROR_TRAP'

%%
% 
% Por lo tanto se puede ver que el algoritmo DFT es más preciso que el del
% trapecio compuesto, puesto que hubo menor error que el valor exacto.
% 

%%
% 
% <<71.PNG>>
% 
% <<72.PNG>>
% 




 


##### SOURCE END #####
--></body></html>