
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Introducci&oacute;n:</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-05-14"><meta name="DC.source" content="Practica5.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Introducci&oacute;n:</h1><!--introduction--><p>Podemos computar DN num&eacute;ricamente usando la DFT (la transformada discreta de Fourier), que utiliza las muestras de una se&ntilde;al peri&oacute;dica <img src="Practica5_eq14833433867325483769.png" alt="$x(t)$"> durante un per&iacute;odo. El intervalo de muestreo es T segundos. Por lo tanto, hay: <img src="Practica5_eq17991288398453338376.png" alt="$N_0 = T_0/T$"> n&uacute;mero de muestras en un per&iacute;odo: <img src="Practica5_eq09699377331652163485.png" alt="$T_0$"></p><p>Para encontrar la relaci&oacute;n entre DN y las muestras de x (t), <img src="Practica5_eq03720543890520871764.png" alt="$D_n= \frac{1}{T_0}\int_{T_0} X(t) e^(-jn\varpi kT) dt$"></p><p><img src="Practica5_eq09679186027026379333.png" alt="$$\lim_{T \rightarrow 0}\frac{1}{N_0 T} \sum _{k=0}^{N_0}-1  X(kT)e^(-jn\varpi kT) T$$&#xA;$$\lim_{T \rightarrow 0}\frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$"></p><p>donde x (kT) es la muestra KTH de x (t) y <img src="Practica5_eq02668798639306139128.png" alt="$$N_0 = \frac{T_0}{T}$">$ <img src="Practica5_eq02779354641064904680.png" alt="$$\Omega_0 = \varpi_0 T = \frac{2\pi }{N_0}$">$ En la pr&aacute;ctica, es imposible hacer <img src="Practica5_eq05130068492524870277.png" alt="$T \rightarrow 0$"> . Podemos hacer T peque&ntilde;o, pero no cero, lo que provocar&aacute; que los datos aumenten sin l&iacute;mite. Por lo tanto, ignoraremos el l&iacute;mite en T con la comprensi&oacute;n impl&iacute;cita de que T es razonablemente peque&ntilde;o. T distinto de cero dar&aacute; lugar a alg&uacute;n error computacional, que es inevitable en cualquier evaluaci&oacute;n num&eacute;rica de una integral.El error resultante de T distinto de cero se denomina error de aliasing. Por lo tanto, podemos expresar como:</p><p><img src="Practica5_eq11268195034532418783.png" alt="$$D_n= \frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$"></p><p>Ahora, <img src="Practica5_eq04266831874103082939.png" alt="$$\Omega_0 N_0 = 2 ?$">$. Por lo tanto, ej <img src="Practica5_eq04256906867831630927.png" alt="$$\Omega_0$">$ (k + N 0) = ej ? 0 k sigue que <img src="Practica5_eq04987746277794382069.png" alt="$$D_n+N_0=D_n$">$</p><p>La propiedad de periodicidad DN + N0 = DN significa que m&aacute;s all&aacute; de n = N0/2, los coeficientes representan los valores para n negativo.Por ejemplo, cuando <img src="Practica5_eq17220364727343488441.png" alt="$$N_0 = 32, D17 = D ? 15, D18 = D-14,..., D31 = D ? 1$">$. El ciclo se repite de nuevo a partir de n = 32. Para este proposito necesitamos muestras de x (t) durante un per&iacute;odo a partir de t = 0. En este algoritmo, tambi&eacute;n es preferible que <img src="Practica5_eq14438439004078460794.png" alt="$N_0$"> sea una potencia de 2, que es <img src="Practica5_eq05989562632921026740.png" alt="$$N_0 = 2^m$">$, donde m es  un entero.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Ejemplo 6.1</a></li><li><a href="#2">Ejemplo 6.2</a></li><li><a href="#3">Ejemplo 6.4</a></li><li><a href="#4">Ejemplo 6.5</a></li><li><a href="#5">Ejemplo 6.7</a></li><li><a href="#6">Computer Example C6.2</a></li><li><a href="#7">M&eacute;todos n&uacute;mericos</a></li></ul></div><h2 id="1">Ejemplo 6.1</h2><pre class="codeinput">piloto()
</pre><pre class="codeoutput error">Undefined function or variable 'piloto'.

Error in Practica5 (line 32)
piloto()
</pre><h2 id="2">Ejemplo 6.2</h2><pre class="codeinput">ejercicio6_2_()
</pre><h2 id="3">Ejemplo 6.4</h2><pre class="codeinput">Ejercicio6_4_()
</pre><h2 id="4">Ejemplo 6.5</h2><pre class="codeinput">Ejercicio6_5_()
</pre><h2 id="5">Ejemplo 6.7</h2><pre class="codeinput">Ejercicio6_7_()
</pre><h2 id="6">Computer Example C6.2</h2><pre class="codeinput">f=@(t) exp(-t/2);
t=[0:0.001:20];
plot(t,f(mod(t,pi)))
sumterms = zeros(25, length(t)); sumterms(1,:) = 0.504; <span class="comment">%15 armonicos</span>
<span class="keyword">for</span> n = 1:size(sumterms,1)-1
sumterms(n+1,:) = 0.504/(1+4*n*1j).*exp(2*n*t*1j);
<span class="keyword">end</span>
x_N = cumsum (sumterms); figure(1); clf; ind = 0;
<span class="keyword">for</span> N = [0,1:2:size(sumterms, 1)-1]
ind = ind+1; subplot (3,3,ind);
plot (t,x_N(N+1,:), <span class="string">'k'</span>,t,f(mod(t,pi))+0j, <span class="string">'r--'</span>); axis ([0 20 -0.2 1.2]);
xlabel (<span class="string">'t'</span>); ylabel ([<span class="string">'x_{'</span>,num2str(N),<span class="string">'} (t)'</span>]);
<span class="keyword">end</span>
</pre><h2 id="7">M&eacute;todos n&uacute;mericos</h2><pre class="codeinput">T_0 = pi; N_0 = 256; T = T_0/N_0; t = (0:T:T*(N_0-1))'; M = 10;
x = exp(-t/2); x(1) = (exp(-pi/2) + 1)/2;
<span class="comment">%--------</span>

figure(1)
D_n = fft (x)/N_0; n = [-N_0/2:N_0/2-1]';

<span class="keyword">for</span> a = 1:1:5
mag_dft(a)=abs(fftshift(D_n(a)));
<span class="keyword">end</span>
<span class="keyword">for</span> a = 1:1:5
ang_dft(a)=angle(fftshift(D_n(a)));
<span class="keyword">end</span>
mag_dft
ang_dft
clf; subplot (2, 2, 1); stem(n, abs(fftshift (D_n)),<span class="string">'k'</span>);
axis ([-M M -.1 .6]); xlabel(<span class="string">'n'</span>); ylabel(<span class="string">'|D_n|'</span>);
subplot (2, 2, 2); stem(n, angle(fftshift(D_n)),<span class="string">'k'</span>);
axis([-M M -pi pi]); xlabel (<span class="string">'n'</span>); ylabel(<span class="string">'\angle D n [rad]'</span>);
<span class="comment">%------</span>

T_0 = pi; N_0 = 256; T = T_0/N_0; W_0=2*pi/T_0; t = (0:T:T*(N_0-1))'; M = 10;

x_0 =@(t) exp(-t/2);
x_1 =@(t) exp(-t/2)*exp(-1j*W_0*t);
x_2 =@(t) exp(-t/2)*exp(-2j*W_0*t);
x_3 =@(t) exp(-t/2)*exp(-3j*W_0*t);
x_4 =@(t) exp(-t/2)*exp(-4j*W_0*t);
</pre><p>Hallando los D0,...D4 (n positiva) por trapecio compuesto</p><pre class="codeinput">figure(2)
n=[0:1:4];
D_n=[trap_com(x_0,0,pi,pi/2)/T_0,trap_com(x_1,0,pi,pi/2)/T_0,trap_com(x_2,0,pi,pi/2)/T_0,trap_com(x_3,0,pi,pi/2)/T_0,trap_com(x_4,0,pi,pi/2)/T_0];
mag_trap=abs(D_n)
ang_trap=angle(D_n)

clf; subplot (2, 2, 1); stem(n, abs( (D_n)),<span class="string">'k'</span>);
axis ([-M M -.1 .6]); xlabel(<span class="string">'n'</span>); ylabel(<span class="string">'|D_n|'</span>);
subplot (2, 2, 2); stem(n, angle((D_n)),<span class="string">'k'</span>);
axis([-M M -pi pi]); xlabel (<span class="string">'n'</span>); ylabel(<span class="string">'\angle D n [rad]'</span>);
hold <span class="string">on</span>
</pre><p>De acuerdo a Lathi, en el ejemplo 6.5, que se desarroll&oacute; en el R10, la serie de Fourier exponencial compleja tiene Dn: <img src="Practica5_eq11462128157880710935.png" alt="$\left.\frac{-1}{\pi (1/2+j2n)}e^{-(1/2+j2n)t}\right |_{t=0}^{\pi}$"> Para llegar al resultado m&aacute;s preciso, no se utiliz&oacute; el resultado final de Lathi que indica <img src="Practica5_eq11815252062284937394.png" alt="$\frac{0.504}{1+j4n}$">. Sino que desarrollando, se encontr&oacute;: <img src="Practica5_eq08029797175683308747.png" alt="$\frac{-1}{\pi (1/2+j2n)}(e^{-\frac{\pi}{2}}-1)$"></p><pre class="codeinput"><span class="keyword">for</span> n=2:1:5
   mag_ex(n)=abs((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1))));
<span class="keyword">end</span>
mag_ex(1)=abs((-exp(-pi/2)+1)/(pi*(0.5)));

<span class="keyword">for</span> n=2:1:5
   ang_ex(n)=angle((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1))));
<span class="keyword">end</span>
ang_ex(1)=angle((-exp(-pi/2)+1)/(pi*(0.5)));

T = table(mag_dft',ang_dft',mag_trap',ang_trap',mag_ex',ang_ex'); T(1:5,:);
T.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
T.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'Abs_DFT'</span>;
T.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'Ang_DFT'</span>;
T.Properties.VariableNames{<span class="string">'Var3'</span>} = <span class="string">'Abs_Trap_Com'</span>;
T.Properties.VariableNames{<span class="string">'Var4'</span>} = <span class="string">'Ang_Trap_Com'</span>;
T.Properties.VariableNames{<span class="string">'Var5'</span>} = <span class="string">'Abs_Exacto'</span>;
T.Properties.VariableNames{<span class="string">'Var6'</span>} = <span class="string">'Ang_Exacto'</span>

<span class="comment">% En su forma rectangular</span>

DFT=mag_dft.*exp(1j.*ang_dft);
TRAP=mag_trap.*exp(1j*ang_trap);
EXAC=mag_ex.*exp(1j*ang_ex);

D= table(DFT',TRAP',EXAC');
D.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
D.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'Dn_por_DFT'</span>;
D.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'Dn_por_Trap_comp'</span>;
D.Properties.VariableNames{<span class="string">'Var3'</span>} = <span class="string">'Dn_exacto'</span>

<span class="comment">% Comparaci&oacute;n</span>
DFT_EXAC=abs(EXAC-DFT);
TRAP_EXAC=abs(EXAC-TRAP);

CMP= table(DFT_EXAC',TRAP_EXAC');
CMP.Properties.RowNames = {<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>,<span class="string">'D4'</span>};
CMP.Properties.VariableNames{<span class="string">'Var1'</span>} = <span class="string">'ERROR_DFT'</span>;
CMP.Properties.VariableNames{<span class="string">'Var2'</span>} = <span class="string">'ERROR_TRAP'</span>

<span class="comment">%Por lo tanto se puede ver que el algoritmo DFT es m&aacute;s preciso que el del</span>
<span class="comment">%trapecio compuesto, puesto que hubo menor error que el valor exacto.</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Introducción:
% Podemos computar DN numéricamente usando la DFT (la transformada discreta de Fourier), que utiliza las muestras
% de una señal periódica $x(t)$ durante un período.
% El intervalo de muestreo es T segundos. Por lo tanto, hay: $N_0 = T_0/T$ número de muestras en un período: $T_0$
% 
% Para encontrar la relación entre DN y las muestras de x (t), $D_n= \frac{1}{T_0}\int_{T_0} X(t) e^(-jn\varpi kT) dt$
% 
% $$\lim_{T \rightarrow 0}\frac{1}{N_0 T} \sum _{k=0}^{N_0}-1  X(kT)e^(-jn\varpi kT) T$$
% $$\lim_{T \rightarrow 0}\frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$
%
% donde x (kT) es la muestra KTH de x (t) y $$N_0 = \frac{T_0}{T}$$
% $$\Omega_0 = \varpi_0 T = \frac{2\pi }{N_0}$$
% En la práctica, es imposible hacer $T \rightarrow 0$ . Podemos hacer T pequeño, pero no cero, lo que provocará que los datos aumenten sin límite.
% Por lo tanto, ignoraremos el límite en T con la comprensión implícita de que T es razonablemente pequeño. T distinto de cero dará lugar a algún error computacional, que es inevitable en cualquier 
% evaluación numérica de una integral.El error resultante de T distinto de cero se denomina error de aliasing. Por lo tanto, podemos expresar como:
%
% $$D_n= \frac{1}{N_0} \sum _{k=0}^{N_0}-1 X(kT)e^(-jn\varpi kT) $$
%   
% Ahora, $$\Omega_0 N_0 = 2 ?$$. Por lo tanto, ej $$\Omega_0$$ (k + N 0) = ej ? 0 k sigue que $$D_n+N_0=D_n$$
%
% La propiedad de periodicidad DN + N0 = DN significa que más allá de n = N0/2, los coeficientes
% representan los valores para n negativo.Por ejemplo, cuando $$N_0 = 32, D17 = D ? 15, D18 = D-14,..., D31 = D ? 1$$. El ciclo se repite de nuevo a partir de n = 32.
% Para este proposito necesitamos muestras de x (t) durante un período a
% partir de t = 0. En este algoritmo, también es preferible que $N_0$ sea
% una potencia de 2, que es $$N_0 = 2^m$$, donde m es  un entero.
%
%
%
%
%
%% Ejemplo 6.1
piloto()
%% Ejemplo 6.2
ejercicio6_2_()
%% Ejemplo 6.4
Ejercicio6_4_()
%% Ejemplo 6.5
Ejercicio6_5_()
%% Ejemplo 6.7
Ejercicio6_7_()
%% Computer Example C6.2
f=@(t) exp(-t/2);
t=[0:0.001:20];
plot(t,f(mod(t,pi)))
sumterms = zeros(25, length(t)); sumterms(1,:) = 0.504; %15 armonicos
for n = 1:size(sumterms,1)-1
sumterms(n+1,:) = 0.504/(1+4*n*1j).*exp(2*n*t*1j);
end
x_N = cumsum (sumterms); figure(1); clf; ind = 0;
for N = [0,1:2:size(sumterms, 1)-1]
ind = ind+1; subplot (3,3,ind);
plot (t,x_N(N+1,:), 'k',t,f(mod(t,pi))+0j, 'rREPLACE_WITH_DASH_DASH'); axis ([0 20 -0.2 1.2]);
xlabel ('t'); ylabel (['x_{',num2str(N),'} (t)']);
end

%% Métodos númericos 
T_0 = pi; N_0 = 256; T = T_0/N_0; t = (0:T:T*(N_0-1))'; M = 10;
x = exp(-t/2); x(1) = (exp(-pi/2) + 1)/2;
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

figure(1)
D_n = fft (x)/N_0; n = [-N_0/2:N_0/2-1]';

for a = 1:1:5
mag_dft(a)=abs(fftshift(D_n(a)));
end
for a = 1:1:5
ang_dft(a)=angle(fftshift(D_n(a)));
end
mag_dft
ang_dft
clf; subplot (2, 2, 1); stem(n, abs(fftshift (D_n)),'k');
axis ([-M M -.1 .6]); xlabel('n'); ylabel('|D_n|');
subplot (2, 2, 2); stem(n, angle(fftshift(D_n)),'k');
axis([-M M -pi pi]); xlabel ('n'); ylabel('\angle D n [rad]');
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

T_0 = pi; N_0 = 256; T = T_0/N_0; W_0=2*pi/T_0; t = (0:T:T*(N_0-1))'; M = 10;

x_0 =@(t) exp(-t/2);
x_1 =@(t) exp(-t/2)*exp(-1j*W_0*t);
x_2 =@(t) exp(-t/2)*exp(-2j*W_0*t);
x_3 =@(t) exp(-t/2)*exp(-3j*W_0*t);
x_4 =@(t) exp(-t/2)*exp(-4j*W_0*t);

%%
% Hallando los D0,...D4 (n positiva) por trapecio compuesto
%%
figure(2)
n=[0:1:4];
D_n=[trap_com(x_0,0,pi,pi/2)/T_0,trap_com(x_1,0,pi,pi/2)/T_0,trap_com(x_2,0,pi,pi/2)/T_0,trap_com(x_3,0,pi,pi/2)/T_0,trap_com(x_4,0,pi,pi/2)/T_0];
mag_trap=abs(D_n)
ang_trap=angle(D_n)

clf; subplot (2, 2, 1); stem(n, abs( (D_n)),'k');
axis ([-M M -.1 .6]); xlabel('n'); ylabel('|D_n|');
subplot (2, 2, 2); stem(n, angle((D_n)),'k');
axis([-M M -pi pi]); xlabel ('n'); ylabel('\angle D n [rad]');
hold on
%%
% De acuerdo a Lathi, en el ejemplo 6.5, que se desarrolló en el R10, la
% serie de Fourier exponencial compleja tiene Dn:
% $\left.\frac{-1}{\pi (1/2+j2n)}e^{-(1/2+j2n)t}\right |_{t=0}^{\pi}$
% Para llegar al resultado más preciso, no se utilizó el resultado final de
% Lathi que indica $\frac{0.504}{1+j4n}$. Sino que desarrollando, se
% encontró: $\frac{-1}{\pi (1/2+j2n)}(e^{-\frac{\pi}{2}}-1)$
%%
for n=2:1:5
   mag_ex(n)=abs((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1)))); 
end
mag_ex(1)=abs((-exp(-pi/2)+1)/(pi*(0.5)));

for n=2:1:5
   ang_ex(n)=angle((-exp(-pi/2)+1)/(pi*(0.5+2j*(n-1)))); 
end
ang_ex(1)=angle((-exp(-pi/2)+1)/(pi*(0.5)));

T = table(mag_dft',ang_dft',mag_trap',ang_trap',mag_ex',ang_ex'); T(1:5,:);
T.Properties.RowNames = {'D0','D1','D2','D3','D4'};
T.Properties.VariableNames{'Var1'} = 'Abs_DFT';
T.Properties.VariableNames{'Var2'} = 'Ang_DFT';
T.Properties.VariableNames{'Var3'} = 'Abs_Trap_Com';
T.Properties.VariableNames{'Var4'} = 'Ang_Trap_Com';
T.Properties.VariableNames{'Var5'} = 'Abs_Exacto';
T.Properties.VariableNames{'Var6'} = 'Ang_Exacto'

% En su forma rectangular

DFT=mag_dft.*exp(1j.*ang_dft);
TRAP=mag_trap.*exp(1j*ang_trap);
EXAC=mag_ex.*exp(1j*ang_ex);

D= table(DFT',TRAP',EXAC');
D.Properties.RowNames = {'D0','D1','D2','D3','D4'};
D.Properties.VariableNames{'Var1'} = 'Dn_por_DFT';
D.Properties.VariableNames{'Var2'} = 'Dn_por_Trap_comp';
D.Properties.VariableNames{'Var3'} = 'Dn_exacto'

% Comparación
DFT_EXAC=abs(EXAC-DFT);
TRAP_EXAC=abs(EXAC-TRAP);

CMP= table(DFT_EXAC',TRAP_EXAC');
CMP.Properties.RowNames = {'D0','D1','D2','D3','D4'};
CMP.Properties.VariableNames{'Var1'} = 'ERROR_DFT';
CMP.Properties.VariableNames{'Var2'} = 'ERROR_TRAP'

%Por lo tanto se puede ver que el algoritmo DFT es más preciso que el del
%trapecio compuesto, puesto que hubo menor error que el valor exacto.



##### SOURCE END #####
--></body></html>